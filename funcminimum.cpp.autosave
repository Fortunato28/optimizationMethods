#include "funcminimum.h"

funcMinimum::funcMinimum()
{
    std::cout << "Enter your function: " << std::endl;
    getline(std::cin, entered_function, '\n');
    if(funcMinimum::entered_function.empty())
        funcMinimum::entered_function = "9(x-6)^2+21";
}

double funcMinimum::myFunction(double x)
{
    // Тут во всю используется библиотека для парсинга введённой функции
    typedef exprtk::symbol_table<double> symbol_table_t;
    typedef exprtk::expression<double> expression_t;
    typedef exprtk::parser<double> parser_t;

    symbol_table_t symbol_table;
    symbol_table.add_variable("x", x);
    symbol_table.add_constants();

    expression_t expression;
    expression.register_symbol_table(symbol_table);

    parser_t parser;
    parser.compile(funcMinimum::entered_function, expression);
    return expression.value();
}

void funcMinimum::goldenSection(double a, double b)
{
    const double alpha = 0.618;     // Константа золотого сечения
    const double epsilon = 0.001;   // Условие останова
    double delta = fabs(b - a);     // Интервал неопределённости
    double xAlpha = a + alpha * delta;
    double xBetta = b - alpha * delta;

    // Условие останова, вывод результата
    if(delta < epsilon)
    {
        goldenMinimum = (a + b) / 2;
        goldenMinimumResult();
        return;
    }

    myFunction(xAlpha) < myFunction(xBetta) ?
                funcMinimum::goldenSection(xBetta, b) :
                funcMinimum::goldenSection(a, xAlpha);
}

void funcMinimum::dichotomy(double a, double b)
{
    const double sigma = 0.0005;    // Шаг приращения
    const double epsilon = 0.001;   // Условие останова
    double delta = fabs(b - a);     // Интервал неопределённости
    double x1 = (a + b - sigma) / 2;
    double x2 = (a + b + sigma) / 2;

    // Условие останова, вывод результата
    if(delta < epsilon)
    {
        dichotomyMinimum = (a + b) / 2;
        dichotomyMinimumResult();
        return;
    }

    myFunction(x1) < myFunction(x2) ?
                funcMinimum::dichotomy(a, x2) :
                funcMinimum::dichotomy(x1, b);
}

void funcMinimum::fibonacci(double a, double b)
{
    double delta = fabs(b - a);     // Интервал неопределённости
    size_t n = 10;                  // Количество итераций
    std::vector<double> fibonacciNumber = {1, 1, 2, 3, 5, 8, 13,
                                           21, 34, 55, 89, 144};
    static size_t i = 0;            // Номер текущей итерации и её приращение
    ++i;
    double x1 = a + (fibonacciNumber.at(n - i - 1) / fibonacciNumber.at(n - i + 1)) * delta;
    double x2 = a + (fibonacciNumber.at(n - i) / fibonacciNumber.at(n - i + 1)) * delta;

    // Условие останова, вывод результата
    if(i == (n - 1))
    {
        fibonacciMinimum = (a + b) / 2;
        fibonacciMinimumResult();
        return;
    }

    myFunction(x1) < myFunction(x2) ?
                funcMinimum::fibonacci(a, x2) :
                funcMinimum::fibonacci(x1, b);
}

void funcMinimum::goldenMinimumResult()
{
    std::cout << "Result of the golden section method:" << std::endl;
    std::cout << "x = " << funcMinimum::goldenMinimum << std::endl;
    std::cout << "f(x) = "<<funcMinimum::myFunction(goldenMinimum) << std::endl;
}

void funcMinimum::dichotomyMinimumResult()
{
    std::cout << "Result of the dichotomy:" << std::endl;
    std::cout << "x = " << funcMinimum::dichotomyMinimum << std::endl;
    std::cout << "f(x) = "<<funcMinimum::myFunction(dichotomyMinimum) << std::endl;
}

void funcMinimum::fibonacciMinimumResult()
{
    std::cout << "Result of the Fibonacci method:" << std::endl;
    std::cout << "x = " << funcMinimum::fibonacciMinimum << std::endl;
    std::cout << "f(x) = "<<funcMinimum::myFunction(fibonacciMinimum) << std::endl;
}
